	ORG 8000H
	DATAOUT EQU 0FFF0H
	DATAIN	EQU 0FFF1H
	
	; 7 SEGMENT ARRAY ADDRESS
	SEG1 EQU 0FFC3h
	SEG2 EQU 0FFC2h
	SEG3 EQU 0FFC1H

	; SEGMENT ARRAY VALUES WILL STORED IN HERE 
	DIGITMEM EQU 20H

START:
	; STORE DIGITS FOR INITIAL SEGMENT DISPLAY
	MOV R0, #DIGITMEM

	MOV @R0, #80H
	INC R0
	MOV @R0, #51H
	INC R0
	MOV @R0, #00H
	INC R0
	MOV @R0, #00H

	; DISPLAY INITIAL STATE
	CALL display

; MAIN LOOP
; POLL THE KEPAD. DISPLAY DIGIT IN THE 7 SEGMENT ARRAY
mainLoop:
	CALL pollKeypad
	MOV A, R0
	JZ mainLoop
	CALL convert
	SUBB A, #10
	JNC mainLoop
	CALL shiftLeft
	CALL display
	CALL delay
	JMP mainLoop

; CONVERT R0 FROM ROW AND COLUMN TO THE DIGIT OF THE KEY
convert:
	MOV A, R0
	MOV R2, A
	SWAP A
	MOV R3, A
	MOV A, R2
	; COLUMN STARTS FROM 0 SO -1
	DEC A
	ANL A, #00000011B
	MOV R2, A
	MOV A, R3
	DEC A
	ANL A, #00000011B
	MOV R3, A
	MOV A, R2
	; MULTIPLY 4 TIMES RESULTS WILL BE 0, 4, 8 
	RL A
	RL A
	ORL A, R3
	MOV R0, A
	RET
	
; SHIFT MECHANISM,
; SWAP EACH SEGMENTS THEN COPY NEXT DIGIT TO LEFT SIDE
shiftLeft:
	; LOAD FIRST TWO DIGITS FROM MEMORY
	MOV A, #DIGITMEM
	MOV R1, A
	MOV A, @R1

	; IN THE FIRST TWO DIGITS
	; WE ONLY NEED LAST ONE,
	; AND IT MUST BE MOVED TO LEFT FOR ONE DIGIT

	; FOR THIS, SWAP AND STORE FIRST DIGIT INTO REGISTER
	SWAP A
	ANL A, #11110000
	MOV R5, A
	
	; LOAD NEXT TWO DIGITS, 
	; WE NEED FIRST ONE DIGIT FROM NEXT TWO DIGITS
	MOV A, R1
	INC A
	MOV R1, A
	MOV A, @R1
	ANL A, #11110000
	SWAP A
	
	; INTEGRATE LAST DIGIT FROM FIRST TWO ARRAY
	; AND FIRST DIGIT FROM NEXT TWO ARRAY
	ORL A, R5
	MOV R5, A

	MOV A, R1
	DEC A
	MOV R1, A

	; AND THEN STORE THE RESULT TO MEMORY
	; THIS VALUE WILL LOADED AGAIN DURING DISPLAY PART
	MOV A, R5
	MOV @R1, A

; DO SAME THINGS FOR MIDDLE TWO ARRAY AND LAST TWO ARRAY
shiftLeft2:
	MOV A, R1
	INC A
	MOV R1, A
	MOV A, @R1

	; SWAP AND STORE
	SWAP A
	ANL A, #11110000
	MOV R5, A
	
	MOV A, R1
	INC A
	MOV R1, A
	MOV A, @R1
	ANL A, #11110000
	SWAP A
	
	ORL A, R5
	MOV R5, A

	MOV A, R1
	DEC A
	MOV R1, A

	MOV A, R5
	MOV @R1, A

; LAST DIGIT IN LAST ARRAY WILL BE NEW NUMBER
; FROM KEYPAD SAME WITH PREVIOUS EXAMPLE
shiftLeft3:
	MOV A, R1
	INC A
	MOV R1, A
	MOV A, @R1

	;MOV A, R1
	SWAP A
	ANL A, #11110000B
	ORL A, R0
	MOV DPTR, #SEG3
	MOVX @DPTR, A
	MOV @R1, A
	RET

; FINALLY DISPLAY SHIFTED DIGITS INTO ACTUAL MEMORY
; LOAD MEMORY VALUES, THEN DISPLAY BY THREE TIMES
display:
	MOV A, #DIGITMEM
	MOV R1, A
	MOV A, @R1

	MOV DPTR, #SEG1
	MOVX @DPTR, A
	
	MOV A, R1
	INC A
	MOV R1, A
	MOV A, @R1
	
	MOV DPTR, #SEG2
	MOVX @DPTR, A

	MOV A, R1
	INC A
	MOV R1, A
	MOV A, @R1
	
	MOV DPTR, #SEG3
	MOVX @DPTR, A
	RET

delay:
	MOV R5, #10H
DELAY1: MOV R6, #0FFh
DELAY2: MOV R7, #0FFh
DELAY3: DJNZ R7, DELAY3
	DJNZ R6, DELAY2
	DJNZ R5, DELAY1
	RET

pollKeypad:
	CALL initColumnOne

columnLoop:
	CALL sendColumnNumber
	CALL getRowNumber
	MOV A, R0
	JNZ keyPressFound
	CALL advanceColumn
	CJNE R7, #5, columnLoop

noKeyPressed:
	MOV R0, #0
	RET

keyPressFound:
	MOV R4, A
	MOV A, R7
	SWAP A
	ORL A, R4
	MOV R0, A
	RET

initColumnOne:
	MOV R7, #1
	MOV R6, #11101111b
	RET

advanceColumn:
	INC R7
	MOV A, R6
	RR A
	MOV R6, A
	RET

sendColumnNumber:
	MOV A, R6
	MOV DPTR, #DATAOUT
	MOVX @DPTR, A
	RET

getRowNumber:
	MOV DPTR, #DATAIN
	MOVX A, @DPTR
	ORL A, #11100000B
	MOV R5, A

checkRow1: 
	MOV A, R5
	CJNE A, #11101111B checkRow2
	MOV R0, #1
	RET
checkRow2:
	MOV A, R5
	CJNE A, #11110111b checkRow3
	MOV R0, #2
	RET
checkRow3: 
	MOV A, R5
	CJNE A, #11111011B checkRow4
	MOV R0, #3
	RET
checkRow4: 
	MOV A, R5
	CJNE A, #11111101B checkRow5
	MOV R0, #4
	RET
checkRow5: 
	MOV A, R5
	CJNE A, #11111110B noRow
	MOV R0, #5
	RET
noRow:
	MOV R0, #0;
	RET
END